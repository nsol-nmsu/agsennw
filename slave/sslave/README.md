# Agriculture Sensor Network Node

This directory contains the files needed to implement the network
sensor node code.  Everything here is pretty simple, so I'll just
give a summaary of most.

#### spi_slave.h
Implements SPI communication protocol for communication with hub,
this code could use a bit of work, communication is sometimes
inconsistent.

#### analog.h, sdi.h
These files are just helpers, they are used in some slaves.
analog.h provides easy access to the chip's ADCs and sdi.h
implements the SDI-12 serial communication protocol.  sdi.h
used to have some inline functions so I put implementations
in the header file, but the implementations should be moved
a .c file at some point and the makefile adjusted accordingly.

#### slave.h
This file defines an interface to the members that any slave.c file
should provide.  Some of the fields aren't currently used by the system
but are provided for future expansion.

#### main.
This file provides a generic main function that should work for any slave type.
Any implementation of a slave should go in a slave.c file and leave main.c unchanged.

#### wind_slave.c, hum_slave.c, humtemp_slave.c, hydra_slave.c, ...
These files are slave implementations for different types of sensor handling.
Slaves can easily be implemented in a slave.c file without having to change any
of the main program code.  Slave implementation details can be found [below](#slave-implementation)

##Slave implementation
Implementing a new slave is pretty simple.  The slave.h file contains all members that
need to be implemented, here's a brief description of each:

#### int slave_id
This should be a unique identified for this specific slave.  Since it's
slave specific it'll need to be written to EEPROM by the programmer on a
slave by slave basis and loaded in slave_init().  This field isn't used by
system yet, so it can contain any int number.

#### char* slave_type
This is a string containing a unique slave type identifier.  It functions as
a mime type for the slave and can contain [A-Za-z0-9_"-"] characters.

#### char* slave_name
This is a unique string identifier for the slave.  Not really sure what it's for
since we already have slave_id, but it was present in the previous code so I just
included it here in case it came in handy.  We don't use this, so it can be anything.

#### char slave_init_date[3]
A 3 byte array representing the deployment date of the slave.  Currently unused,
included for future expansion.  Date is of the format [day, month, year], where
year is number of years since 2000.

#### char slave_rcount
The number of readable channels this slave has.

#### char slave_wcount
The number of writable channels for this slave.

#### char* slave_info
A descriptive string for the slave, containing some kind of slave description.
Currently unused, included for future expansion.

#### int slave_init()
Function called before any of the slave features are used, should perform any
necessary slave initialization.

#### unsigned slave_measure()
This function should start a measurement, and return the time in milliseconds
until the slave is finished acquiring data.

#### void slave_run_measure()
This function is called after slave_measure(), and should perform any tasks
data preparation/acquisition tasks necessary.  The slave's communication with
its hub will be halted until completion of this routine.

#### char* slave_read( unsigned ch )
Returns the slave data.  We use a string so we can return any kind of data.
The string should be formated as:

    "data_type:data_value:data_unit"

and if multiple values are returned then they should be separated by newlines like:

    "data_type1:data_value1:data_unit1\ndata_type1:data_value2:data_unit2"

For example here's a data string that could be generated by the humtemp_slave.c:

    temp:27.5:F
    hum:0.314:RH

Here we have a temperature value in Fahrenheit and a humidity value as a humidity ratio.

#### int slave_write( const char* msg, unsigned ch )
Allows for writing to some slave channels for configuration and such, not currently used,
can set slave_wcount to 0 and return 0 from this function.

#### int slave_apply( unsigned ch )
This is called after a slave write, in case the value wasn't committed in the previous function.

#### Makefile Entry
For each implemented slave an entry in the makefile should also be added.
Each slave entry will need a SLAVE variable pointing to the slave.c file:

    hydra:  SLAVE = hydra_slave.c

Each entry will also need an F_CPU variable to indicate at what cpu frequency
the slave program will be running.

    hydra:  F_CPU = 8000000

And each entry needs a FUSES variable to indicate the fuses to burn into the chip:

    hydra:  FUSES = -U lfuse:w:0xe2:m -U hfuse:w:0xdf:m -U efuse:w:0xff:m

Then each slave needs the build rule, which is usually just something like:

    hydra:  deploy hydra_slave.c

## Deploying the Code
Code deployment is pretty simple, just plug in a USBTiny programmer device
with your Attiny84 connected and run:

    make hydra

replacing 'hydra' with the slave type you want to deploy.  If you're using a programmer
other than USBTiny then you'll need to change the PROGRAMMER variable in the makefile.
